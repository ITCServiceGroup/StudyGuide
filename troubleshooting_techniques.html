<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Troubleshooting Techniques Study Guide</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }

        .section {
            margin-bottom: 40px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
        }

        h1 {
            color: #2196F3;
            border-bottom: 2px solid #2196F3;
            padding-bottom: 10px;
        }

        h2 {
            color: #1976D2;
            margin-top: 20px;
        }

        .key-point {
            background-color: #e3f2fd;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #2196F3; /* Restored border */
            border-radius: 4px;
        }

        .checklist {
            background-color: #e8f5e9;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #4caf50;
            border-radius: 4px;
        }

        .warning {
            background-color: #ffebee;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #f44336;
            border-radius: 4px;
        }

        .scenario {
            background-color: #fff3e0;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #ff9800;
            border-radius: 4px;
        }

        .interactive-element {
            background-color: #fff;
            padding: 20px;
            margin: 15px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .router-placement {
            width: 840px; /* Increased width + 40px padding */
            height: 740px; /* Increased height + 40px padding */
            position: relative;
            border: 1px solid #ccc;
            margin: 20px auto; /* Centered horizontally */
            background-color: #f5f5f5;
            /* overflow: hidden; Removed as it might interfere */
        }

        .router {
            position: absolute;
            z-index: 10;
            cursor: grab;
            width: 60px; /* Increased size */
            height: 60px; /* Increased size */
            user-select: none;
            touch-action: none;
            will-change: left, top;
            left: 0;
            top: 0;
            transition: left 0.05s ease-out, top 0.05s ease-out;
            pointer-events: auto;
            backface-visibility: hidden;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        .router:active, .mesh-extender:active {
            cursor: grabbing;
        }

        .mesh-extender {
            position: absolute;
            z-index: 10;
            cursor: grab;
            width: 60px;
            height: 60px;
            user-select: none;
            touch-action: none;
            will-change: left, top;
            left: 0;
            top: 0;
            transition: left 0.05s ease-out, top 0.05s ease-out;
            pointer-events: auto;
            backface-visibility: hidden;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }


        .signal-strength {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        th, td {
            padding: 12px;
            border: 1px solid #ddd;
            text-align: left;
        }

        th {
            background-color: #f5f5f5;
        }

        button {
            padding: 8px 16px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }

        button:hover {
            background-color: #1976D2;
        }

        .flowchart {
            width: 100%;
            max-width: 800px;
            margin: 15px auto;
            padding: 15px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .decision-node {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #2196F3;
            border-radius: 5px;
            /* cursor: pointer; Removed as buttons handle clicks */
        }

        .decision-node button { /* Style buttons within flowchart */
             display: block;
             margin: 5px 0;
        }


        .controls { /* Shared controls class */
            margin: 10px 0;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        #signalInfo {
            background-color: #e3f2fd;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .room {
            position: absolute;
            /* border: 2px solid #666; */ /* Border removed, will be drawn separately */
            border: none; /* Explicitly remove border */
            background-color: rgba(200, 200, 200, 0.1);
            pointer-events: none;
            z-index: 1; /* Lower z-index so walls draw on top */
        }

        .room-label {
            position: absolute;
            font-size: 12px;
            color: #333;
            pointer-events: none;
            user-select: none;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 1px 3px;
            border-radius: 2px;
            z-index: 5; /* Increased z-index to be above obstacles */
        }

        .fixed-obstacle {
            position: absolute;
            pointer-events: none;
            z-index: 4; /* Above rooms */
            /* Added styles for W/D labels */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: rgba(0, 0, 0, 0.6);
            text-align: center;
        }

        .interference-source {
            position: absolute;
            pointer-events: none;
            z-index: 3; /* Above rooms, below obstacles */
            opacity: 0; /* Hidden by default */
            transition: all 0.3s ease-in-out;
            border: 2px dashed rgba(244, 67, 54, 0);
            animation: none;
        }

        .interference-source.active {
            opacity: 0.3;
            border-color: rgba(244, 67, 54, 0.8);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 0.3;
            }
            50% {
                transform: scale(1.05);
                opacity: 0.5;
            }
            100% {
                transform: scale(1);
                opacity: 0.3;
            }
        }

        .interference-source.bluetooth.active {
            /* Changed from blue to purple */
            /* Removed background fill */
            border-color: rgba(156, 39, 176, 0.8); /* Purple */
        }

        .interference-source.babyMonitor.active {
             /* Removed background fill */
             border-color: rgba(244, 67, 54, 0.8); /* Keep border color from .interference-source.active */
        }

        .interference-buttons {
            margin: 10px 0;
            display: flex;
            gap: 10px;
        }

        .interference-button {
            padding: 10px 20px;
            background-color: #E0E0E0;
            color: #424242;
            border: 2px solid #BDBDBD;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .interference-button::before {
            content: '';
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #9E9E9E;
            transition: all 0.3s ease;
        }

        .interference-button:hover {
            background-color: #EEEEEE;
            border-color: #9E9E9E;
        }

        .interference-button.active {
            background-color: #FBE9E7;
            border-color: #F44336;
            color: #D32F2F;
        }

        .interference-button.active::before {
            background-color: #F44336;
            box-shadow: 0 0 8px rgba(244, 67, 54, 0.5);
        }

        .interference-button.bluetooth.active {
            background-color: #F3E5F5; /* Light Purple */
            border-color: #9C27B0; /* Purple */
            color: #7B1FA2; /* Dark Purple */
        }

        .interference-button.bluetooth.active::before {
            background-color: #9C27B0; /* Purple */
            box-shadow: 0 0 8px rgba(156, 39, 176, 0.5); /* Purple */
        }

        .tooltip {
            margin-top: 10px;
            padding: 8px 12px;
            background-color: #E3F2FD;
            border: 1px solid #BBDEFB;
            border-radius: 4px;
            color: #1976D2;
            font-size: 0.9em;
            line-height: 1.4;
            width: 100%;
            text-align: center;
        }

        .tooltip::before {
            content: 'ðŸ’¡ ';
        }
    </style>
</head>
<body>
    <h1>Troubleshooting Techniques Study Guide</h1>

    <div class="section">
        <h2>1. Systematic Troubleshooting Approach</h2>
        <p>Effective troubleshooting requires a methodical approach to identify and resolve network issues efficiently.</p>
        <div class="key-point">
            <h3>Key Steps in Network Troubleshooting:</h3>
            <ol>
                <li>Identify and document the problem</li>
                <li>Establish a theory of probable cause</li>
                <li>Test the theory</li>
                <li>Create action plan and implement solution</li>
                <li>Verify system functionality</li>
            </ol>
        </div>
        <div class="interactive-element">
            <h3>Interactive Troubleshooting Flowchart</h3>
            <div class="flowchart" id="troubleshootingFlow">
                <!-- Flowchart nodes will be added by JavaScript -->
            </div>
        </div>
    </div>

    <div class="section">
        <h2>2. Router Placement and Signal Optimization</h2>
        <p>Proper router placement is crucial for optimal WiFi coverage and performance.</p>
        <div class="key-point">
            <h3>Router Placement Guidelines:</h3>
            <ul>
                <li>Central location in the coverage area</li>
                <li>Elevated position (off the floor)</li>
                <li>Away from metal objects and appliances</li>
                <li>Away from thick walls and obstacles</li>
                <li>Away from water features (fish tanks, etc.)</li>
            </ul>
        </div>
        <div class="scenario">
            <strong>Common Scenario:</strong> A customer complains about weak WiFi in their backyard despite having good signal in the living room. The router is placed near a large fish tank. Solution: Move the router away from the fish tank and closer to a window facing the backyard.
        </div>
        <div class="interactive-element">
            <h3>Router Placement Simulator</h3>
            <div id="signalInfo">Signal Strength at Router: 100% | Mesh Extender: Not Placed</div>
            <div class="controls">
                <button id="meshExtenderButton" class="interference-button">Add Mesh Extender</button>
                <div class="tooltip">Place a mesh extender to boost WiFi coverage. Signal strength depends on router's signal at extender location.</div>
            </div>
            <div class="router-placement" id="routerPlacement">
                <svg id="router" class="router" draggable="true" viewBox="0 0 64 64">
                    <rect x="4" y="24" width="56" height="16" rx="4" fill="#64B5F6"/>
                    <line x1="16" y1="20" x2="16" y2="12" stroke="#333" stroke-width="3" stroke-linecap="round"/>
                    <line x1="32" y1="20" x2="32" y2="8" stroke="#333" stroke-width="3" stroke-linecap="round"/>
                    <line x1="48" y1="20" x2="48" y2="12" stroke="#333" stroke-width="3" stroke-linecap="round"/>
                    <circle cx="12" cy="32" r="3" fill="#1976D2"/>
                    <circle cx="22" cy="32" r="3" fill="#1976D2"/>
                    <circle cx="32" cy="32" r="3" fill="#1976D2"/>
                    <circle cx="42" cy="32" r="3" fill="#1976D2"/>
                    <circle cx="52" cy="32" r="3" fill="#1976D2"/>
                </svg>
                <svg id="meshExtender" class="mesh-extender" style="display: none;" viewBox="0 0 64 64">
                    <!-- Main body - rounded square -->
                    <rect x="8" y="20" width="48" height="24" rx="6" fill="#81D4FA"/>
                    <!-- Curved arrow indicating signal boost -->
                    <path d="M 16,18 A 20,20 0 0 1 48,18" stroke="#2196F3" stroke-width="3" fill="none" stroke-linecap="round"/>
                    <path d="M 20,14 A 24,24 0 0 1 44,14" stroke="#2196F3" stroke-width="3" fill="none" stroke-linecap="round"/>
                    <!-- Signal indicators -->
                    <circle cx="20" cy="32" r="2.5" fill="#0D47A1"/>
                    <circle cx="32" cy="32" r="2.5" fill="#0D47A1"/>
                    <circle cx="44" cy="32" r="2.5" fill="#0D47A1"/>
                    <!-- Small feet/stands -->
                    <rect x="16" y="44" width="8" height="2" rx="1" fill="#333"/>
                    <rect x="40" y="44" width="8" height="2" rx="1" fill="#333"/>
                </svg>
                <canvas id="signalStrength" class="signal-strength"></canvas>
                <div id="floorplan"></div>
                <div id="wallContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 2;"></div> <!-- Container for unique walls -->
                <div id="fixedObstacles"></div>
                <div id="interferenceSources"></div>
            </div>
            <div class="interference-buttons">
                <button id="bluetoothToggle" class="interference-button bluetooth">Bluetooth Soundbar</button>
                <button id="babyMonitorToggle" class="interference-button">Baby Monitor</button>
                <div class="tooltip">Toggle interference sources to see their impact on WiFi signal</div>
            </div>
            <p id="placementAdvice">Drag the router to test different positions in this home layout. The heatmap shows signal strength considering walls, appliances, and active interference sources.</p>
        </div>
    </div>

    <div class="section">
        <h2>3. Common Network Issues and Solutions</h2>
        <table>
            <tr><th>Issue</th><th>Common Causes</th><th>Troubleshooting Steps</th><th>Prevention</th></tr>
            <tr><td>No Internet Connection</td><td><ul><li>Physical connection issues</li><li>Router/modem problems</li><li>ISP outage</li></ul></td><td><ol><li>Check physical connections</li><li>Verify power to devices</li><li>Reset router/modem</li><li>Contact ISP</li></ol></td><td><ul><li>Regular maintenance</li><li>Secure connections</li><li>UPS backup</li></ul></td></tr>
            <tr><td>Slow Connection</td><td><ul><li>Network congestion</li><li>WiFi interference</li><li>Hardware limitations</li></ul></td><td><ol><li>Run speed tests</li><li>Check for interference</li><li>Monitor network usage</li><li>Update firmware</li></ol></td><td><ul><li>Regular speed tests</li><li>Channel optimization</li><li>Traffic management</li></ul></td></tr>
            <tr><td>Intermittent Connection</td><td><ul><li>Signal interference</li><li>Loose connections</li><li>Environmental factors</li></ul></td><td><ol><li>Check connections</li><li>Monitor signal strength</li><li>Identify interference</li><li>Test different channels</li></ol></td><td><ul><li>Secure connections</li><li>Regular signal checks</li><li>Environmental controls</li></ul></td></tr>
        </table>
        <div class="warning"><strong>Important:</strong> Always verify basic connectivity (power, physical connections) before moving to more complex troubleshooting steps.</div>
    </div>

    <div class="section">
        <h2>4. WiFi Interference Management</h2>
        <p>Understanding and managing various sources of WiFi interference is crucial for maintaining optimal network performance.</p>
        <div class="key-point">
            <h3>Common Interference Sources:</h3>
            <table>
                <tr><th>Source</th><th>Impact</th><th>Solution</th></tr>
                <tr><td>Microwave Ovens</td><td>Temporary disruption of 2.4 GHz signals</td><td>Use 5 GHz band, relocate router</td></tr>
                <tr><td>Bluetooth Devices</td><td>2.4 GHz interference</td><td>Switch to 5 GHz, maintain distance</td></tr>
                <tr><td>Baby Monitors</td><td>Continuous signal interference</td><td>Change channels, use different frequency</td></tr>
                <tr><td>Cordless Phones</td><td>Periodic signal disruption</td><td>Use DECT phones, separate frequencies</td></tr>
            </table>
        </div>
        <div class="scenario"><strong>Common Scenario:</strong> A customer's smart home devices (lights, plugs) disconnect when the microwave runs...</div>
    </div>

    <div class="section">
        <h2>5. Smart Home Device Troubleshooting</h2>
        <p>Smart home devices present unique networking challenges...</p>
        <div class="key-point"><h3>Common Smart Device Issues:</h3><ul><li>Frequent disconnections</li><li>Slow response times</li><li>...</li></ul></div>
        <div class="checklist"><h3>Smart Device Best Practices:</h3><ul><li>Network Setup<ul><li>...</li></ul></li><li>Device Placement<ul><li>...</li></ul></li></ul></div>
        <div class="warning"><strong>Important:</strong> Many smart home devices only support 2.4 GHz WiFi...</div>
    </div>

    <div class="section">
        <h2>6. Real-World Troubleshooting Scenarios</h2>
        <p>Understanding how to approach and solve common customer issues...</p>
        <div class="scenario"><h3>Scenario 1: Intermittent WiFi Disconnections</h3><div class="key-point">...</div></div>
        <div class="scenario"><h3>Scenario 2: Slow Internet After Equipment Upgrade</h3><div class="key-point">...</div></div>
        <div class="scenario"><h3>Scenario 3: Smart Home Device Connectivity</h3><div class="key-point">...</div></div>
        <div class="tip"><h3>Scenario Documentation Best Practices:</h3><ul><li>...</li></ul></div>
    </div>

    <div class="section">
        <h2>7. Environmental Factors</h2>
        <p>Environmental conditions can significantly impact network performance...</p>
        <div class="checklist"><h3>Environmental Considerations:</h3><ul><li>Temperature<ul><li>...</li></ul></li><li>...</li></ul></div>
        <div class="scenario"><strong>Weather Impact Scenario:</strong> ...</div>
    </div>

    <div class="section">
        <h2>8. Construction Material Impact</h2>
        <p>Different building materials can significantly affect WiFi signal strength...</p>
        <div class="key-point"><h3>Material Impact Chart:</h3><table>...</table></div>
        <div class="tip"><h3>Signal Optimization Tips:</h3><ul><li>...</li></ul></div>
    </div>

    <div class="section">
        <h2>9. Advanced Smart Device Troubleshooting</h2>
        <p>Complex smart home setups require specialized troubleshooting approaches.</p>
        <div class="key-point"><h3>Device-Specific Solutions:</h3><table>...</table></div>
        <div class="warning"><h3>Critical Considerations:</h3><ul><li>...</li></ul></div>
    </div>

    <script>
        // Floorplan Configuration (Define first) - Scaled by 2x
        const padding = 20; // Define padding offset
        const floorplanData = {
            rooms: [
                { name: "Living Room", x: 40 + padding, y: 40 + padding, width: 400, height: 300, zoneAttenuation: 0.1, externalWalls: ["north", "west"] },
                { name: "Kitchen", x: 440 + padding, y: 40 + padding, width: 300, height: 240, zoneAttenuation: 0.4, externalWalls: ["north", "east"] },
                { name: "Dining Room", x: 440 + padding, y: 280 + padding, width: 300, height: 200, zoneAttenuation: 0.1, externalWalls: ["east"] },
                { name: "Bedroom 1", x: 40 + padding, y: 340 + padding, width: 240, height: 240, zoneAttenuation: 0.05, externalWalls: ["west"] }, // Increased height
                { name: "Bedroom 2", x: 280 + padding, y: 340 + padding, width: 240, height: 240, zoneAttenuation: 0.05 }, // Increased height
                { name: "Bedroom 3", x: 520 + padding, y: 480 + padding, width: 220, height: 220, zoneAttenuation: 0.05, externalWalls: ["east", "south"] }, // Increased height
                { name: "Bathroom 1", x: 40 + padding, y: 580 + padding, width: 240, height: 120, zoneAttenuation: 0.4, externalWalls: ["west", "south"] }, // Adjusted y, height, Increased width
                { name: "Bathroom 2", x: 280 + padding, y: 580 + padding, width: 240, height: 120, zoneAttenuation: 0.4, externalWalls: ["south"] } // Adjusted y, width, height, externalWalls
            ],
            fixedObstacles: [
                { type: "refrigerator", x: 441 + padding, y: 41 + padding, width: 50, height: 40, attenuation: 0.8 }, // Moved next to cabinet
                { type: "washer", x: 450 + padding, y: 370 + padding, width: 40, height: 40, attenuation: 0.7 }, // Moved to Dining Room nook
                { type: "dryer", x: 450 + padding, y: 415 + padding, width: 40, height: 40, attenuation: 0.7 }, // Moved to Dining Room nook
                // Bathroom 1 Mirror: Centered on top wall (shared with Bedroom 1)
                { type: "mirror", room: "Bathroom 1", x: (40 + padding) + (240 / 2) - (60 / 2), y: (580 + padding) + 5, width: 60, height: 10, attenuation: 0.5 },
                // Bathroom 2 Mirror: Centered on top wall (shared with Bedroom 2)
                { type: "mirror", room: "Bathroom 2", x: (280 + padding) + (240 / 2) - (60 / 2), y: (580 + padding) + 5, width: 60, height: 10, attenuation: 0.5 },
                { type: "cabinet", x: 441 + padding, y: 44 + padding, width: 50, height: 236, attenuation: 0.6 } // Moved to left kitchen wall, full height, wider
            ],
            interferenceSources: [
                { name: "bluetooth", room: "Living Room", x: 200 + padding, y: 200 + padding, radius: 80, attenuation: 0.5, active: false }, // Reduced attenuation
                { name: "babyMonitor", room: "Bedroom 2", x: 400 + padding, y: 400 + padding, radius: 100, attenuation: 0.3, active: false } // Increased attenuation
            ]
        };

        // Wait for DOM to load before manipulating it
        document.addEventListener('DOMContentLoaded', function() {

            // --- Router Placement Simulator Elements & Logic ---
            const routerPlacement = document.getElementById("routerPlacement");
            const router = document.getElementById("router");
            const meshExtender = document.getElementById("meshExtender");
            const meshExtenderButton = document.getElementById("meshExtenderButton");
            const signalStrengthCanvas = document.getElementById("signalStrength");
            const signalCtx = signalStrengthCanvas.getContext("2d", { willReadFrequently: true });
            const interferenceElements = {}; // Store references to the DOM elements for interference sources
            let currentRoom = null; // Track current room for external wall calculations

            // Mesh extender state
            let meshExtenderPlaced = false;
            let isMeshExtenderDragging = false;
            let meshExtenderDimensions = { width: 60, height: 60 };
            let meshExtenderLastPosition = { x: 0, y: 0 };
            let meshExtenderStrength = 0;

            // Mesh extender functions
            function toggleMeshExtender() {
                if (!meshExtender || !meshExtenderButton) return;
                
                meshExtenderPlaced = !meshExtenderPlaced;
                meshExtender.style.display = meshExtenderPlaced ? 'block' : 'none';
                meshExtenderButton.classList.toggle('active');

                if (meshExtenderPlaced) {
                    // Place mesh extender in center of router's current strongest coverage area
                    const routerX = parseFloat(router.style.left) || 0;
                    const routerY = parseFloat(router.style.top) || 0;
                    const centerX = Math.round(routerX + (routerDimensions.width / 2));
                    const centerY = Math.round(routerY + (routerDimensions.height / 2));

                    // Find a good initial position (e.g., strongest signal area that needs coverage)
                    const bestPosition = findBestMeshExtenderPosition(centerX, centerY);
                    updateMeshExtenderPosition(bestPosition.x, bestPosition.y);
                }

                updateSignalStrength();
                updateSignalInfo();
            }

            function findBestMeshExtenderPosition(routerX, routerY) {
                // For now, place it 2/3 of the distance across the living room
                const livingRoom = floorplanData.rooms.find(r => r.name === "Living Room");
                if (livingRoom) {
                    return {
                        x: livingRoom.x + Math.round(livingRoom.width * 0.66) - (meshExtenderDimensions.width / 2),
                        y: livingRoom.y + Math.round(livingRoom.height / 2) - (meshExtenderDimensions.height / 2)
                    };
                }
                // Fallback position
                return { x: routerX + 200, y: routerY };
            }

            // Mesh extender constants and helper functions
            const MESH_MIN_INPUT_THRESHOLD = 0.05; // 5% minimum input signal
            const MESH_EFFECTIVE_RANGE = 1.2; // 20% more range than router

            function getScaledBoost(minOutput, maxOutput, input, minInput, maxInput) {
                const scale = (input - minInput) / (maxInput - minInput);
                return minOutput + (maxOutput - minOutput) * Math.min(1, Math.max(0, scale));
            }

            function getMeshBoostFactor(inputSignal) {
                // Below minimum threshold
                if (inputSignal < MESH_MIN_INPUT_THRESHOLD) return 0;

                // Tier 1: 5-15% input -> 30-40% output
                if (inputSignal <= 0.15) {
                    return getScaledBoost(0.30, 0.40, inputSignal, 0.05, 0.15);
                }
                
                // Tier 2: 16-30% input -> 41-60% output
                if (inputSignal <= 0.30) {
                    return getScaledBoost(0.41, 0.60, inputSignal, 0.16, 0.30);
                }
                
                // Tier 3: 31-50% input -> 61-80% output
                if (inputSignal <= 0.50) {
                    return getScaledBoost(0.61, 0.80, inputSignal, 0.31, 0.50);
                }
                
                // Above 50% input -> 100% output
                return 1.0;
            }

            function calculateCombinedSignalStrength(x, y, routerX, routerY, meshX, meshY) {
                // First calculate direct router signal to this point
                const routerSignal = calculateSignalAtPoint(x, y, routerX, routerY);
                
                if (!meshExtenderPlaced) return routerSignal;

                // Calculate mesh extender's received signal from router
                meshExtenderStrength = calculateSignalAtPoint(meshX, meshY, routerX, routerY);

                // If below minimum threshold, mesh extender doesn't function
                if (meshExtenderStrength < MESH_MIN_INPUT_THRESHOLD) {
                    return routerSignal;
                }

                // Calculate boosted output based on input signal strength tiers
                const boostFactor = getMeshBoostFactor(meshExtenderStrength);
                
                // Calculate distance-based falloff from mesh extender
                const dx = x - meshX;
                const dy = y - meshY;
                const distanceFromMesh = Math.sqrt(dx * dx + dy * dy);
                const maxRange = Math.min(signalStrengthCanvas.width, signalStrengthCanvas.height) * 
                    0.5 * 5 * MESH_EFFECTIVE_RANGE;
                
                // Calculate mesh signal with boosted strength but normal attenuation
                let meshSignal = boostFactor * Math.pow(Math.max(0, 1 - (distanceFromMesh / maxRange)), 2);
                
                // Apply normal attenuation factors (walls, obstacles, etc.)
                const totalAttenuation = calculateAttenuation(x, y, meshX, meshY);
                meshSignal *= Math.max(0, 1 - totalAttenuation);

                // Return the stronger of the two signals
                return Math.max(routerSignal, meshSignal);
            }

            function calculateAttenuation(x, y, sourceX, sourceY) {
                let totalAttenuation = 0;

                // Check for external wall crossings
                if (checkExternalWallsInPath(sourceX, sourceY, x, y, floorplanData.rooms)) {
                    totalAttenuation += 0.65; // High attenuation for external walls
                }

                // Check room boundaries for internal wall crossings
                for (const room of floorplanData.rooms) {
                    const pointInRoom = x >= room.x && x <= room.x + room.width &&
                                     y >= room.y && y <= room.y + room.height;
                    const sourceInRoom = sourceX >= room.x && sourceX <= room.x + room.width &&
                                       sourceY >= room.y && sourceY <= room.y + room.height;

                    if (pointInRoom !== sourceInRoom) {
                        totalAttenuation += 0.08; // Normal attenuation for internal walls
                    }

                    // Apply zone attenuation if the point is inside the room
                    if (pointInRoom) {
                        totalAttenuation += room.zoneAttenuation;
                    }
                }

                // Apply obstacles
                for (const obstacle of floorplanData.fixedObstacles) {
                    if (lineIntersectsRect(sourceX, sourceY, x, y,
                        obstacle.x, obstacle.y,
                        obstacle.x + obstacle.width,
                        obstacle.y + obstacle.height)) {
                        totalAttenuation += obstacle.attenuation;
                    }
                }

                return totalAttenuation;
            }

            function updateMeshExtenderPosition(x, y) {
                if (!meshExtender || !routerPlacement) return;

                // Ensure coordinates are numbers and within bounds
                x = Math.round(Math.max(0, Math.min(x, routerPlacement.offsetWidth - meshExtenderDimensions.width)));
                y = Math.round(Math.max(0, Math.min(y, routerPlacement.offsetHeight - meshExtenderDimensions.height)));

                // Update position state
                meshExtenderLastPosition = { x, y };

                // Update position
                meshExtender.style.left = x + 'px';
                meshExtender.style.top = y + 'px';

                // Schedule signal update
                requestAnimationFrame(() => {
                    updateSignalStrength();
                    updateSignalInfo();
                });
            }

            // Mesh extender drag handlers
            if (meshExtender) {
                meshExtender.setAttribute('draggable', 'false');

                function startMeshExtenderDrag(e) {
                    if (!meshExtenderPlaced) return;
                    e.preventDefault();
                    isMeshExtenderDragging = true;
                    const rect = meshExtender.getBoundingClientRect();
                    if (e.type === 'mousedown') {
                        currentX = e.clientX - rect.left;
                        currentY = e.clientY - rect.top;
                    } else {
                        currentX = e.touches[0].clientX - rect.left;
                        currentY = e.touches[0].clientY - rect.top;
                    }
                    meshExtender.style.cursor = 'grabbing';
                }

                function moveMeshExtender(e) {
                    if (!isMeshExtenderDragging || !meshExtender || !routerPlacement) return;
                    e.preventDefault();

                    const rect = routerPlacement.getBoundingClientRect();
                    const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
                    const clientY = e.type === 'mousemove' ? e.clientY : e.touches[0].clientY;

                    const newX = clientX - rect.left - currentX;
                    const newY = clientY - rect.top - currentY;

                    updateMeshExtenderPosition(newX, newY);
                }

                function stopMeshExtenderDrag() {
                    isMeshExtenderDragging = false;
                    if (meshExtender) {
                        meshExtender.style.cursor = 'grab';
                    }
                }

                // Mouse events for mesh extender
                meshExtender.addEventListener('mousedown', startMeshExtenderDrag);
                meshExtender.addEventListener('mouseenter', () => {
                    if (meshExtenderPlaced && !isMeshExtenderDragging) {
                        meshExtender.style.cursor = 'grab';
                    }
                });
                meshExtender.addEventListener('mouseleave', () => {
                    if (meshExtenderPlaced && !isMeshExtenderDragging) {
                        meshExtender.style.cursor = 'default';
                    }
                });

                // Touch events for mesh extender
                meshExtender.addEventListener('touchstart', startMeshExtenderDrag, { passive: false });
                document.addEventListener('touchmove', moveMeshExtender, { passive: false });
                document.addEventListener('touchend', stopMeshExtenderDrag);
                document.addEventListener('touchcancel', stopMeshExtenderDrag);

                // Mouse events for mesh extender global handlers (needed for drag outside element)
                document.addEventListener('mousemove', moveMeshExtender);
                document.addEventListener('mouseup', stopMeshExtenderDrag);
            }

            // Add mesh extender button click handler
            if (meshExtenderButton) {
                meshExtenderButton.addEventListener('click', toggleMeshExtender);
            }

            // Router state management
            let lastKnownPosition = { x: 0, y: 0 };
            let routerDimensions = { width: 60, height: 60 }; // Updated default size

            // Initialize Floorplan, Walls, and Interference Elements
            function initializeFloorplan() {
                const floorplanContainer = document.getElementById("floorplan");
                const wallContainer = document.getElementById("wallContainer"); // Get the new wall container
                const fixedObstaclesContainer = document.getElementById("fixedObstacles");
                const interferenceContainer = document.getElementById("interferenceSources");
                const wallThickness = 2; // Define wall thickness
                const wallColor = "#666"; // Define wall color

                // Clear previous elements if any (important for re-initialization if needed)
                if (floorplanContainer) floorplanContainer.innerHTML = '';
                if (wallContainer) wallContainer.innerHTML = ''; // Clear previous walls
                if (fixedObstaclesContainer) fixedObstaclesContainer.innerHTML = '';
                if (interferenceContainer) interferenceContainer.innerHTML = '';
                // Clear the interferenceElements object
                for (const key in interferenceElements) {
                    delete interferenceElements[key];
                }

                const uniqueWallSegments = new Set();

                // --- Calculate Unique Wall Segments ---
                floorplanData.rooms.forEach(room => {
                    const x1 = room.x;
                    const y1 = room.y;
                    const x2 = room.x + room.width;
                    const y2 = room.y + room.height;

                    // Top wall: (x1, y1) to (x2, y1)
                    uniqueWallSegments.add(`h-${x1}-${x2}-${y1}`);
                    // Bottom wall: (x1, y2) to (x2, y2)
                    uniqueWallSegments.add(`h-${x1}-${x2}-${y2}`);
                    // Left wall: (x1, y1) to (x1, y2)
                    uniqueWallSegments.add(`v-${x1}-${y1}-${y2}`);
                    // Right wall: (x2, y1) to (x2, y2)
                    uniqueWallSegments.add(`v-${x2}-${y1}-${y2}`);

                    // Add room background and label (without border)
                    if (floorplanContainer) {
                        const roomElement = document.createElement("div");
                        roomElement.className = "room";
                        roomElement.style.left = room.x + "px";
                        roomElement.style.top = room.y + "px";
                        roomElement.style.width = room.width + "px";
                        roomElement.style.height = room.height + "px";

                        const label = document.createElement("div");
                        label.className = "room-label";
                        label.textContent = room.name;
                        // Default label position
                        let labelLeft = room.x + 5;
                        let labelTop = room.y + 5;

                        // Adjust Kitchen label position to avoid obstacles
                        if (room.name === "Kitchen") {
                            labelLeft = room.x + 55; // Move further right
                            labelTop = room.y + 5;
                        }

                        label.style.left = labelLeft + "px";
                        label.style.top = labelTop + "px";

                        floorplanContainer.appendChild(roomElement);
                        floorplanContainer.appendChild(label);
                    }
                });

                // --- Add Laundry Room Label ---
                const diningRoom = floorplanData.rooms.find(r => r.name === "Dining Room");
                const bedroom2 = floorplanData.rooms.find(r => r.name === "Bedroom 2");
                if (diningRoom && bedroom2 && floorplanContainer) {
                    const overlapX = Math.max(diningRoom.x, bedroom2.x);
                    const overlapY = Math.max(diningRoom.y, bedroom2.y);
                    const overlapEndX = Math.min(diningRoom.x + diningRoom.width, bedroom2.x + bedroom2.width);
                    const overlapEndY = Math.min(diningRoom.y + diningRoom.height, bedroom2.y + bedroom2.height);
                    const overlapWidth = overlapEndX - overlapX;
                    const overlapHeight = overlapEndY - overlapY;

                    if (overlapWidth > 0 && overlapHeight > 0) {
                        const laundryLabel = document.createElement("div");
                        laundryLabel.className = "room-label"; // Reuse style
                        laundryLabel.textContent = "Laundry";
                        laundryLabel.style.left = (overlapX + 5) + "px"; // Position top-left like other labels
                        laundryLabel.style.top = (overlapY + 5) + "px"; // Position top-left like other labels
                        // Removed specific background color to use default .room-label style
                        floorplanContainer.appendChild(laundryLabel); // Add to floorplan container
                    }
                }

                // --- Draw Unique Walls ---
                if (wallContainer) {
                    uniqueWallSegments.forEach(segmentKey => {
                        const parts = segmentKey.split('-');
                        const type = parts[0];
                        const x1 = parseInt(parts[1]);
                        const y1_or_x2 = parseInt(parts[2]);
                        const y2_or_y1 = parseInt(parts[3]);

                        const wallElement = document.createElement("div");
                        wallElement.style.position = "absolute";
                        wallElement.style.backgroundColor = wallColor;

                        if (type === 'h') { // Horizontal wall
                            const x2 = y1_or_x2;
                            const y = y2_or_y1;
                            wallElement.style.left = x1 + "px";
                            wallElement.style.top = (y - wallThickness / 2) + "px"; // Center vertically
                            wallElement.style.width = (x2 - x1) + "px";
                            wallElement.style.height = wallThickness + "px";
                        } else { // Vertical wall (type === 'v')
                            const y1 = y1_or_x2;
                            const y2 = y2_or_y1;
                            const x = x1;
                            wallElement.style.left = (x - wallThickness / 2) + "px"; // Center horizontally
                            wallElement.style.top = y1 + "px";
                            wallElement.style.width = wallThickness + "px";
                            wallElement.style.height = (y2 - y1) + "px";
                        }
                        wallContainer.appendChild(wallElement);
                    });
                }


                // Add fixed obstacles (Keep this logic)
                if (fixedObstaclesContainer) {
                    floorplanData.fixedObstacles.forEach(obstacle => {
                        const element = document.createElement("div");
                        element.className = "fixed-obstacle";
                        element.style.left = obstacle.x + "px";
                        element.style.top = obstacle.y + "px";
                        element.style.width = obstacle.width + "px";
                        element.style.height = obstacle.height + "px";
                        element.style.backgroundColor = getObstacleColor(obstacle.type);
                        element.title = obstacle.type;
                        // Add W/D labels
                        if (obstacle.type === 'washer') {
                            element.textContent = 'W';
                        } else if (obstacle.type === 'dryer') {
                            element.textContent = 'D';
                        }
                        // Ensure fridge renders on top of cabinet
                        if (obstacle.type === 'refrigerator') {
                            element.style.zIndex = '5'; // Higher z-index than default fixed-obstacle
                        }
                        fixedObstaclesContainer.appendChild(element);
                    });
                }

                // Add interference sources AND store references
                if (interferenceContainer) {
                    floorplanData.interferenceSources.forEach(source => {
                        const element = document.createElement("div");
                        element.className = "interference-source";
                        element.classList.add(`interference-${source.name}`);
                        element.style.left = (source.x - source.radius) + "px";
                        element.style.top = (source.y - source.radius) + "px";
                        element.style.width = (source.radius * 2) + "px";
                        element.style.height = (source.radius * 2) + "px";
                        element.style.borderRadius = "50%";
                        // Removed initial background color setting
                        // Set initial visibility based on 'active' status in data
                        if (source.active) {
                            element.classList.add("active");
                        }
                        interferenceContainer.appendChild(element);
                        interferenceElements[source.name] = element; // Store reference
                    });
                }
            }

            function getObstacleColor(type) {
                switch(type) {
                    case "refrigerator": return "#90A4AE";
                    case "washer": case "dryer": return "#78909C";
                    case "mirror": return "rgba(200, 200, 200, 0.8)";
                    case "cabinet": return "#8D6E63";
                    default: return "#BDBDBD";
                }
            }

            function lineIntersectsRect(x1, y1, x2, y2, rx1, ry1, rx2, ry2) {
                const minX = Math.min(x1, x2), maxX = Math.max(x1, x2);
                const minY = Math.min(y1, y2), maxY = Math.max(y1, y2);
                // Basic bounding box check first
                if (maxX < rx1 || minX > rx2 || maxY < ry1 || minY > ry2) {
                    return false;
                }
                 // More precise check needed if bounding boxes overlap, but for simplicity:
                 // Check if either endpoint is inside the rectangle
                 if ((x1 >= rx1 && x1 <= rx2 && y1 >= ry1 && y1 <= ry2) || (x2 >= rx1 && x2 <= rx2 && y2 >= ry1 && y2 <= ry2)) {
                     return true;
                 }
                 // A simple check if the line segment crosses the rectangle's center area (approximation)
                 const centerX = (rx1 + rx2) / 2;
                 const centerY = (ry1 + ry2) / 2;
                 return (minX <= centerX && maxX >= centerX && minY <= centerY && maxY >= centerY);
            }

            // Helper function to get color based on signal strength (0-1)
            function getColorForStrength(strength) {
                const green = { r: 76, g: 175, b: 80 };
                const blue = { r: 33, g: 150, b: 243 };
                const yellow = { r: 255, g: 193, b: 7 };
                const red = { r: 244, g: 67, b: 54 };

                let r, g, b;

                // Adjusted thresholds for larger green/blue areas
                if (strength >= 0.6) { // Interpolate Green to Blue (1.0 -> 0.6)
                    const t = (strength - 0.6) / (1.0 - 0.6);
                    r = Math.round(blue.r + (green.r - blue.r) * t);
                    g = Math.round(blue.g + (green.g - blue.g) * t);
                    b = Math.round(blue.b + (green.b - blue.b) * t);
                } else if (strength >= 0.3) { // Interpolate Blue to Yellow (0.6 -> 0.3)
                    const t = (strength - 0.3) / (0.6 - 0.3);
                    r = Math.round(yellow.r + (blue.r - yellow.r) * t);
                    g = Math.round(yellow.g + (blue.g - yellow.g) * t);
                    b = Math.round(yellow.b + (blue.b - yellow.b) * t);
                } else { // Interpolate Yellow to Red (0.3 -> 0.0)
                    const t = strength / 0.3;
                    r = Math.round(red.r + (yellow.r - red.r) * t);
                    g = Math.round(red.g + (yellow.g - red.g) * t);
                    b = Math.round(red.b + (yellow.b - red.b) * t);
                }
                // Ensure values are within 0-255 range
                r = Math.max(0, Math.min(255, r));
                g = Math.max(0, Math.min(255, g));
                b = Math.max(0, Math.min(255, b));
                 return { r, g, b };
            }

            // Helper function: Check if a line segment intersects a circle
            function lineSegmentIntersectsCircle(x1, y1, x2, y2, cx, cy, r) {
                // Vector d = (x2-x1, y2-y1)
                const dx = x2 - x1;
                const dy = y2 - y1;
                // Vector f = (x1-cx, y1-cy)
                const fx = x1 - cx;
                const fy = y1 - cy;

                const a = dx * dx + dy * dy;
                const b = 2 * (fx * dx + fy * dy);
                const c = (fx * fx + fy * fy) - r * r;

                let discriminant = b * b - 4 * a * c;
                if (discriminant < 0) {
                    // No intersection
                    return false;
                } else {
                    // Ray intersects circle, check if intersection is within segment
                    discriminant = Math.sqrt(discriminant);
                    const t1 = (-b - discriminant) / (2 * a);
                    const t2 = (-b + discriminant) / (2 * a);

                    // Check if either intersection point falls within the line segment (0 <= t <= 1)
                    if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) {
                        return true; // Segment intersects circle
                    }

                    // Check if the segment is entirely within the circle (both endpoints inside)
                    const distSq1 = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy);
                    const distSq2 = (x2 - cx) * (x2 - cx) + (y2 - cy) * (y2 - cy);
                    if (distSq1 <= r * r && distSq2 <= r * r) {
                        return true; // Segment is fully inside
                    }

                    return false; // No intersection within the segment bounds
                }
            }

            // Original function restored for accurate text display calculation
             function calculateSignalAtPoint(x, y, routerX, routerY) {
                 // Input validation
                 if (!Number.isFinite(x) || !Number.isFinite(y) ||
                    !Number.isFinite(routerX) || !Number.isFinite(routerY)) {
                    return 0;
                }

                // First, check if router is within any active interference zones
                let routerInterferencePenalty = 1.0;
                for (const source of floorplanData.interferenceSources) {
                    if (source.active) {
                        const routerToInterferenceDistance = Math.sqrt(
                            Math.pow(routerX - source.x, 2) +
                            Math.pow(routerY - source.y, 2)
                        );

                        if (routerToInterferenceDistance <= source.radius) {
                            // Router is within interference radius
                            // Calculate proximityFactor (0 at center, 1 at edge)
                            const proximityFactor = routerToInterferenceDistance / source.radius;
                            // Calculate base penalty (0 at center, 1 at edge, steeper falloff)
                            const basePenaltyFactor = Math.pow(proximityFactor, 1.5);
                            // Calculate signal multiplier: 0.25 at center (75% reduction), 1.0 at edge (0% reduction)
                            const signalMultiplier = 0.25 + (1 - 0.25) * basePenaltyFactor;
                            // Apply the multiplier to the overall penalty
                            routerInterferencePenalty *= signalMultiplier;
                        }
                    }
                }

                const dx = x - routerX;
                const dy = y - routerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                // Use canvas dimensions for maxRadius to ensure it covers the area
                 // Note: Using smaller radius here for more realistic falloff in detailed calc
                const maxRadius = Math.min(signalStrengthCanvas.width, signalStrengthCanvas.height) * 0.5 * 5; // Increased multiplier from 3 to 5


                // Base signal strength calculation using quadratic decay
                // Apply router interference penalty to base strength
                let strength = Math.pow(Math.max(0, 1 - (distance / maxRadius)), 2) * routerInterferencePenalty;

                // Count walls crossed
                let wallsCrossed = 0;
                let totalAttenuation = 0;

                // Check for external wall crossings first
                if (checkExternalWallsInPath(routerX, routerY, x, y, floorplanData.rooms)) {
                    totalAttenuation += 0.65; // High attenuation for external walls
                }

                // Check room boundaries for internal wall crossings
                for (const room of floorplanData.rooms) {
                    const pointInRoom = x >= room.x && x <= room.x + room.width &&
                                     y >= room.y && y <= room.y + room.height;
                    const routerInRoom = routerX >= room.x && routerX <= room.x + room.width &&
                                       routerY >= room.y && routerY <= room.y + room.height;

                    if (pointInRoom !== routerInRoom) {
                        wallsCrossed++;
                        totalAttenuation += 0.08; // Normal attenuation for internal walls
                    }

                    // Apply zone attenuation if the point is inside the room
                    if (pointInRoom) {
                        totalAttenuation += room.zoneAttenuation;
                    }
                }


                // Apply obstacles
                for (const obstacle of floorplanData.fixedObstacles) {
                    if (lineIntersectsRect(routerX, routerY, x, y,
                        obstacle.x, obstacle.y,
                        obstacle.x + obstacle.width,
                        obstacle.y + obstacle.height)) {
                        totalAttenuation += obstacle.attenuation;
                    }
                }
                // Apply interference sources
                for (const source of floorplanData.interferenceSources) {
                    if (source.active) {
                        const distToSource = Math.sqrt(
                            Math.pow(x - source.x, 2) +
                            Math.pow(y - source.y, 2)
                        );
                        if (distToSource <= source.radius) {
                            const interferenceStrength = 1 - (distToSource / source.radius);
                            totalAttenuation += source.attenuation * interferenceStrength;
                        }

                        // ADDED: Check if the line of sight passes through the interference zone,
                        // but only apply attenuation if the point itself isn't already inside (avoid double counting)
                        if (distToSource > source.radius && lineSegmentIntersectsCircle(routerX, routerY, x, y, source.x, source.y, source.radius)) {
                            // Apply attenuation if the line passes through.
                            // Using a slightly reduced factor for pass-through compared to being inside.
                            totalAttenuation += source.attenuation * 0.75; // Example: 75% of the full attenuation
                        }
                    }
                }

                // Apply total attenuation to base strength
                strength *= Math.max(0, 1 - totalAttenuation);

                 return Math.max(0, Math.min(1, strength));
             }


            // Removed the simplified calculateBaseSignalAtPoint function


            function updateSignalStrength() {
                if (!routerPlacement || !signalCtx || !signalStrengthCanvas || !router) {
                    console.warn('Missing required elements');
                    return;
                }

                try {
                    // Get router and mesh extender positions
                    const routerX = parseFloat(router.style.left) || 0;
                    const routerY = parseFloat(router.style.top) || 0;
                    const meshX = parseFloat(meshExtender.style.left) || 0;
                    const meshY = parseFloat(meshExtender.style.top) || 0;
                    
                    // Add validation for dimensions
                    const routerWidth = router.offsetWidth || 60;
                    const routerHeight = router.offsetHeight || 60;
                    const meshWidth = meshExtender.offsetWidth || 60;
                    const meshHeight = meshExtender.offsetHeight || 60;

                    // Calculate centers with validation
                    const routerCenterX = Math.floor(routerX + (routerWidth / 2));
                    const routerCenterY = Math.floor(routerY + (routerHeight / 2));
                    const meshCenterX = Math.floor(meshX + (meshWidth / 2));
                    const meshCenterY = Math.floor(meshY + (meshHeight / 2));

                    // Validate coordinates
                    if (!Number.isFinite(routerCenterX) || !Number.isFinite(routerCenterY)) {
                        console.warn('Invalid router position:', { routerCenterX, routerCenterY });
                        return;
                    }

                    // Ensure canvas dimensions are valid
                    const canvasWidth = signalStrengthCanvas.width;
                    const canvasHeight = signalStrengthCanvas.height;
                    if (!canvasWidth || !canvasHeight) {
                        console.warn('Invalid canvas dimensions');
                        return;
                    }

                    // Clear canvas
                    signalCtx.clearRect(0, 0, canvasWidth, canvasHeight);

                    // Create pixel data for the base signal (distance only)
                    const imageData = signalCtx.createImageData(canvasWidth, canvasHeight);
                    const data = imageData.data;

                    for (let y = 0; y < canvasHeight; y++) {
                        for (let x = 0; x < canvasWidth; x++) {
                            // Calculate combined signal strength
                            const strength = meshExtenderPlaced ? 
                                calculateCombinedSignalStrength(x, y, routerCenterX, routerCenterY, meshCenterX, meshCenterY) : 
                                calculateSignalAtPoint(x, y, routerCenterX, routerCenterY);
                            const color = getColorForStrength(strength);
                            // Base alpha on strength, maybe slightly less intense overall
                            const alpha = Math.floor(strength * 0.6 * 255);

                            const i = (y * canvasWidth + x) * 4;
                            data[i] = color.r;     // Red
                            data[i + 1] = color.g; // Green
                            data[i + 2] = color.b; // Blue
                            data[i + 3] = alpha;   // Alpha
                        }
                    }
                    // Draw the calculated signal map directly
                    signalCtx.putImageData(imageData, 0, 0);

                    // No need for separate shadow drawing now

                    // --- Apply Final Blur ---
                    signalCtx.filter = 'blur(16px)';
                    // Draw the modified canvas onto itself to apply the blur
                    // Use a temporary canvas to avoid feedback loop issues with drawImage on self
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvasWidth;
                    tempCanvas.height = canvasHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(signalStrengthCanvas, 0, 0); // Copy current state
                    signalCtx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear original
                    signalCtx.drawImage(tempCanvas, 0, 0); // Draw blurred image back

                    // Reset the filter so other drawing isn't affected
                    // Reset the filter so other drawing isn't affected
                    signalCtx.filter = 'none';

                } catch (error) {
                    console.error('Error updating signal strength:', error);
                }
            }

            function updateSignalInfo() {
                if (!router) return;
                
                // Ensure router has valid dimensions before calculating
                if (!router.offsetWidth || !router.offsetHeight) {
                    return; // Silently return if dimensions aren't ready
                }
                
                // Parse positions as numbers with fallback to 0
                const routerLeft = parseFloat(router.style.left) || 0;
                const routerTop = parseFloat(router.style.top) || 0;
                
                // Only proceed if we have valid position values
                if (isNaN(routerLeft) || isNaN(routerTop)) {
                    return; // Silently return if positions aren't valid
                }

                const routerX = routerLeft + (router.offsetWidth / 2);
                const routerY = routerTop + (router.offsetHeight / 2);

                // Use the original detailed calculation for the text display
                const strengthAtRouter = calculateSignalAtPoint(routerX, routerY, routerX, routerY); // Need original function back for this
                const signalInfo = document.getElementById("signalInfo");
                if (signalInfo) {
                    const signalPercent = Math.round(Math.max(0, Math.min(1, strengthAtRouter)) * 100);
                    let infoText = `Signal Strength at Router: ${signalPercent}%`;
                    
                    if (meshExtenderPlaced && meshExtender) {
                        const meshLeft = parseFloat(meshExtender.style.left) || 0;
                        const meshTop = parseFloat(meshExtender.style.top) || 0;
                        const meshX = meshLeft + (meshExtender.offsetWidth / 2);
                        const meshY = meshTop + (meshExtender.offsetHeight / 2);
                        
                        // Calculate mesh extender's received and output signals
                        meshExtenderStrength = calculateSignalAtPoint(meshX, meshY, routerX, routerY);
                        const meshInputPercent = Math.round(meshExtenderStrength * 100);
                        
                        // Get output based on new tier system
                        const boostFactor = getMeshBoostFactor(meshExtenderStrength);
                        const outputPercent = Math.round(boostFactor * 100);
                        
                        infoText += ` | Mesh Extender Input: ${meshInputPercent}% | Output: ${outputPercent}%`;
                    } else {
                        infoText += " | Mesh Extender: Not Placed";
                    }
                    
                    signalInfo.textContent = infoText;
                }
            }


            // Helper function to determine if two line segments intersect
            function doLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
                const denom = (x4 - x3) * (y1 - y2) - (x1 - x2) * (y4 - y3);
                if (denom === 0) return false;
                const ua = ((x4 - x3) * (y1 - y3) - (x1 - x3) * (y4 - y3)) / denom;
                const ub = ((x2 - x1) * (y1 - y3) - (x1 - x3) * (y2 - y1)) / denom;
                return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
            }

            // Helper function to check if a line segment intersects with any room's external walls
            function checkExternalWallsInPath(x1, y1, x2, y2, rooms) {
                for (const room of rooms) {
                    if (room.externalWalls && isExternalWall(x1, y1, x2, y2, room)) {
                        return true;
                    }
                }
                return false;
            }

            // Helper function to determine if a wall crossing is through an external wall
            function isExternalWall(x1, y1, x2, y2, room) {
                if (!room || !room.externalWalls) return false;

                for (const wall of room.externalWalls) {
                    let wallStart, wallEnd;
                    switch (wall) {
                        case "north":
                            wallStart = { x: room.x, y: room.y };
                            wallEnd = { x: room.x + room.width, y: room.y };
                            break;
                        case "south":
                            wallStart = { x: room.x, y: room.y + room.height };
                            wallEnd = { x: room.x + room.width, y: room.y + room.height };
                            break;
                        case "west":
                            wallStart = { x: room.x, y: room.y };
                            wallEnd = { x: room.x, y: room.y + room.height };
                            break;
                        case "east":
                            wallStart = { x: room.x + room.width, y: room.y };
                            wallEnd = { x: room.x + room.width, y: room.y + room.height };
                            break;
                        default:
                            continue;
                    }
                    if (doLinesIntersect(x1, y1, x2, y2, wallStart.x, wallStart.y, wallEnd.x, wallEnd.y)) {
                        return true;
                    }
                }
                return false;
            }

            function updateCanvasDimensions() {
                if (!routerPlacement || !signalStrengthCanvas) {
                    console.warn('Missing elements for canvas dimension update');
                    return;
                }

                const containerRect = routerPlacement.getBoundingClientRect();
                signalStrengthCanvas.style.width = containerRect.width + 'px';
                signalStrengthCanvas.style.height = containerRect.height + 'px';
                signalStrengthCanvas.width = containerRect.width;
                signalStrengthCanvas.height = containerRect.height;

                // Force a redraw of the signal visualization
                requestAnimationFrame(() => {
                    updateSignalStrength();
                });
            }

            // Add a mutation observer to watch for size changes
            const resizeObserver = new ResizeObserver(entries => {
                for (const entry of entries) {
                    if (entry.target === routerPlacement) {
                        updateCanvasDimensions();
                    }
                }
            });

            if (routerPlacement) {
                resizeObserver.observe(routerPlacement);
            }

            // --- Event Listeners ---
            window.addEventListener('resize', updateCanvasDimensions);

            // Router movement state
            let isDragging = false;
            let currentX = 0;
            let currentY = 0;

            // Remove default draggability
            if (router) {
                router.setAttribute('draggable', 'false');
                
                function startDrag(e) {
                    e.preventDefault();
                    isDragging = true;
                    const rect = router.getBoundingClientRect();
                    if (e.type === 'mousedown') {
                        currentX = e.clientX - rect.left;
                        currentY = e.clientY - rect.top;
                    } else {
                        currentX = e.touches[0].clientX - rect.left;
                        currentY = e.touches[0].clientY - rect.top;
                    }
                    router.style.cursor = 'grabbing';
                }

                function moveRouter(e) {
                    if (!isDragging || !router || !routerPlacement) return;
                    e.preventDefault();

                    const rect = routerPlacement.getBoundingClientRect();
                    const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
                    const clientY = e.type === 'mousemove' ? e.clientY : e.touches[0].clientY;

                    // Calculate new position
                    const newX = clientX - rect.left - currentX;
                    const newY = clientY - rect.top - currentY;

                    // Update router position with our helper function
                    updateRouterPosition(newX, newY);
                }

                function stopDrag() {
                    isDragging = false;
                    router.style.cursor = 'grab';
                }

                // Mouse events
                router.addEventListener('mousedown', startDrag);
                document.addEventListener('mousemove', moveRouter);
                document.addEventListener('mouseup', stopDrag);

                // Touch events
                router.addEventListener('touchstart', startDrag, { passive: false });
                document.addEventListener('touchmove', moveRouter, { passive: false });
                document.addEventListener('touchend', stopDrag);
                document.addEventListener('touchcancel', stopDrag);

                // Initial cursor style
                router.style.cursor = 'grab';
            }

            // Remove redundant event listeners since they're now handled in moveRouter
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
            document.addEventListener('touchcancel', stopDrag);

            // Set initial cursor style when not dragging
            router.addEventListener('mouseenter', function() {
                if (!isDragging) router.style.cursor = 'grab';
            });
            
            router.addEventListener('mouseleave', function() {
                if (!isDragging) router.style.cursor = 'default';
            });


            // Interference Toggle Buttons
            const bluetoothToggle = document.getElementById("bluetoothToggle");
            const babyMonitorToggle = document.getElementById("babyMonitorToggle");

            if (bluetoothToggle) {
                bluetoothToggle.addEventListener("click", function() {
                    const sourceData = floorplanData.interferenceSources.find(s => s.name === "bluetooth");
                    if (!sourceData) return;
                    sourceData.active = !sourceData.active;
                    this.classList.toggle("active");
                    if (interferenceElements["bluetooth"]) {
                         interferenceElements["bluetooth"].classList.toggle("active");
                    }
                    updateSignalStrength();
                    updateSignalInfo();
                });
            }

            if (babyMonitorToggle) {
                babyMonitorToggle.addEventListener("click", function() {
                    const sourceData = floorplanData.interferenceSources.find(s => s.name === "babyMonitor");
                     if (!sourceData) return;
                    sourceData.active = !sourceData.active;
                    this.classList.toggle("active");
                     if (interferenceElements["babyMonitor"]) {
                        interferenceElements["babyMonitor"].classList.toggle("active");
                     }
                    updateSignalStrength();
                    updateSignalInfo();
                });
            }

            // --- Troubleshooting Flowchart ---
            const flowchart = document.getElementById("troubleshootingFlow");
            const steps = [
                // Initial Step
                { question: "What is the primary issue?", options: ["No Internet", "Slow Internet", "Intermittent Connection", "Specific Device Issue"], next: { "No Internet": "Check Modem/ONT Lights", "Slow Internet": "Run Speed Test", "Intermittent Connection": "Check Intermittent Pattern", "Specific Device Issue": "Check Device Specifics" } },
                // No Internet Path
                { question: "Check Modem/ONT Lights", options: ["Lights Normal", "Lights Abnormal"], next: { "Lights Normal": "Check Router Lights", "Lights Abnormal": "Power Cycle Modem/ONT" } },
                { question: "Power Cycle Modem/ONT", options: ["Still Abnormal", "Now Normal"], next: { "Still Abnormal": "Check Modem Power/Connections", "Now Normal": "Check Router Lights" } },
                { question: "Check Modem Power/Connections", options: ["Still Abnormal", "Now Normal"], next: { "Still Abnormal": "Contact ISP - Hardware", "Now Normal": "Check Router Lights" } },
                { question: "Check Router Lights", options: ["Lights Normal", "Lights Abnormal"], next: { "Lights Normal": "Check Physical Connections", "Lights Abnormal": "Power Cycle Router" } },
                { question: "Power Cycle Router", options: ["Still Abnormal", "Now Normal"], next: { "Still Abnormal": "Check Router Power/Connections", "Now Normal": "Check Physical Connections" } },
                { question: "Check Router Power/Connections", options: ["Still Abnormal", "Now Normal"], next: { "Still Abnormal": "Router Hardware Issue", "Now Normal": "Check Physical Connections" } },
                { question: "Check Physical Connections", options: ["Connections Secure", "Connections Loose/Damaged"], next: { "Connections Secure": "Test Wired Connection", "Connections Loose/Damaged": "Fix Connections" } },
                { question: "Fix Connections", options: ["Now Working", "Still Not Working"], next: { "Now Working": "Issue Resolved", "Still Not Working": "Test Wired Connection" } },
                { question: "Test Wired Connection", options: ["Works When Wired", "No Connection Wired"], next: { "Works When Wired": "WiFi Issue", "No Connection Wired": "Test Direct to Modem" } },
                { question: "Test Direct to Modem", options: ["Works Direct to Modem", "No Connection to Modem"], next: { "Works Direct to Modem": "Router Issue", "No Connection to Modem": "ISP Issue" } },
                // Slow Internet Path
                { question: "Run Speed Test", options: ["Speed Significantly Slow", "Speed Normal"], next: { "Speed Significantly Slow": "Power Cycle Network Equipment", "Speed Normal": "Check Device Limits" } },
                { question: "Power Cycle Network Equipment", options: ["Speed Improved", "Still Slow"], next: { "Speed Improved": "Monitor Performance", "Still Slow": "Test Direct to Modem Speed" } },
                { question: "Test Direct to Modem Speed", options: ["Still Slow at Modem", "Speed OK at Modem"], next: { "Still Slow at Modem": "Contact ISP - Speed", "Speed OK at Modem": "Check Router Settings" } },
                { question: "Check Router Settings", options: ["Speed Improved", "Still Slow"], next: { "Speed Improved": "Monitor Performance", "Still Slow": "WiFi Issue" } },
                // Intermittent Connection Path
                { question: "Check Intermittent Pattern", options: ["Pattern Found", "No Clear Pattern"], next: { "Pattern Found": "Check Physical Connections", "No Clear Pattern": "Check WiFi Interference" } },
                { question: "Check WiFi Interference", options: ["Interference Found", "No Interference"], next: { "Interference Found": "Mitigate Interference", "No Interference": "Check Signal Strength" } },
                { question: "Check Signal Strength", options: ["Signal Weak", "Signal Strong"], next: { "Signal Weak": "Optimize Router Placement", "Signal Strong": "Check Router Logs" } },
                { question: "Optimize Router Placement", options: ["Improved", "Still Issues"], next: { "Improved": "Monitor Performance", "Still Issues": "Consider Mesh/Extender" } },
                // Specific Device Issue Path
                { question: "Check Device Specifics", options: ["Only This Device", "Multiple Devices"], next: { "Only This Device": "Check Device Connection", "Multiple Devices": "What is the primary issue?" } },
                { question: "Check Device Connection", options: ["Not Connected", "Shows Connected"], next: { "Not Connected": "Basic Device Fixes", "Shows Connected": "Check Device Functionality" } },
                { question: "Basic Device Fixes", options: ["Now Working", "Still Issues"], next: { "Now Working": "Monitor Device", "Still Issues": "Check Device Compatibility" } },
                { question: "Check Device Functionality", options: ["Internet Issue", "Local Network Issue", "Performance Issue"], next: { "Internet Issue": "Check DNS Settings", "Local Network Issue": "Restart Network Equipment", "Performance Issue": "Check Signal Strength" } },
                // WiFi Branch Entry Point
                { question: "WiFi Issue", options: ["Signal Issue", "Speed Issue", "Interference Issue", "Connection Drops"], next: { "Signal Issue": "Check Signal Strength", "Speed Issue": "Check WiFi Channel", "Interference Issue": "Check Interference Sources", "Connection Drops": "Check Intermittent Pattern" } },
                // WiFi Specific Checks
                { question: "Check WiFi Channel", options: ["Channel Congested", "Channel Clear"], next: { "Channel Congested": "Change WiFi Channel", "Channel Clear": "Check Connected Devices" } },
                { question: "Check Connected Devices", options: ["High Usage Found", "Normal Usage"], next: { "High Usage Found": "Manage Bandwidth", "Normal Usage": "Check Router Firmware" } },
                { question: "Check Router Firmware", options: ["Update Available", "Firmware Current"], next: { "Update Available": "Update Router Firmware", "Firmware Current": "Consider Router Reset" } },
                // Terminal/Concluding Steps
                { question: "Issue Resolved", options: ["Start Over?"], next: { "Start Over?": "What is the primary issue?" } },
                { question: "Monitor Performance", options: ["Start Over?"], next: { "Start Over?": "What is the primary issue?" } },
                { question: "Monitor Device", options: ["Start Over?"], next: { "Start Over?": "What is the primary issue?" } },
                { question: "Contact ISP - Hardware", options: ["Contact ISP about potential hardware failure.", "Start Over?"], next: { "Start Over?": "What is the primary issue?" } },
                { question: "Contact ISP - Speed", options: ["Contact ISP regarding slow speeds.", "Start Over?"], next: { "Start Over?": "What is the primary issue?" } },
                { question: "ISP Issue", options: ["Contact ISP for assistance.", "Start Over?"], next: { "Start Over?": "What is the primary issue?" } },
                { question: "Router Hardware Issue", options: ["Consider factory reset or replacing router.", "Start Over?"], next: { "Start Over?": "What is the primary issue?" } },
                { question: "Router Issue", options: ["Troubleshoot router (settings, reset, replace).", "Start Over?"], next: { "Start Over?": "What is the primary issue?" } },
                { question: "Consider Router Reset", options: ["Factory reset router (requires reconfiguration). Test again.", "Start Over?"], next: { "Start Over?": "What is the primary issue?" } },
                { question: "Consider Mesh/Extender", options: ["Recommend WiFi Extender or Mesh System for better coverage.", "Start Over?"], next: { "Start Over?": "What is the primary issue?" } },
                // Missing Intermediate Steps (Added for completeness based on previous versions)
                { question: "Check Device Limits", options: ["Device OK", "Device Limited"], next: { "Device OK": "WiFi Issue", "Device Limited": "Advise User on Device Limits" } },
                { question: "Advise User on Device Limits", options: ["Inform user about potential device limitations.", "Start Over?"], next: { "Start Over?": "What is the primary issue?" } },
                { question: "Mitigate Interference", options: ["Interference Reduced", "Still Issues"], next: { "Interference Reduced": "Monitor Performance", "Still Issues": "Check Signal Strength" } },
                { question: "Check Router Logs", options: ["Errors Found", "No Errors"], next: { "Errors Found": "Troubleshoot Router Error", "No Errors": "Test Wired to Router Stability" } },
                { question: "Troubleshoot Router Error", options: ["Update Firmware", "Check Overheating", "Factory Reset"], next: { "Update Firmware": "Update Router Firmware", "Check Overheating": "Ensure Ventilation", "Factory Reset": "Consider Router Reset" } },
                { question: "Ensure Ventilation", options: ["Ensure router has adequate ventilation.", "Start Over?"], next: { "Start Over?": "What is the primary issue?" } },
                { question: "Test Wired to Router Stability", options: ["Still Intermittent", "Stable Wired"], next: { "Still Intermittent": "Test Wired to Modem Stability", "Stable Wired": "WiFi Issue" } },
                { question: "Test Wired to Modem Stability", options: ["Still Intermittent", "Stable at Modem"], next: { "Still Intermittent": "ISP Issue", "Stable at Modem": "Router Issue" } },
                { question: "Check Device Compatibility", options: ["Device Compatible", "Device Incompatible"], next: { "Device Compatible": "Monitor Device", "Device Incompatible": "Advise on Compatibility" } },
                { question: "Advise on Compatibility", options: ["Advise user on potential device incompatibility.", "Start Over?"], next: { "Start Over?": "What is the primary issue?" } },
                { question: "Check DNS Settings", options: ["DNS OK", "DNS Issue"], next: { "DNS OK": "Restart Network Equipment", "DNS Issue": "Correct DNS Settings" } },
                { question: "Correct DNS Settings", options: ["Correct DNS settings on device or router.", "Start Over?"], next: { "Start Over?": "What is the primary issue?" } },
                { question: "Restart Network Equipment", options: ["Issue Resolved", "Still Issues"], next: { "Issue Resolved": "Monitor Performance", "Still Issues": "Consider Device Defect" } },
                { question: "Consider Device Defect", options: ["Consider the possibility of a defective device.", "Start Over?"], next: { "Start Over?": "What is the primary issue?" } },
                { question: "Check Interference Sources", options: ["Source Found", "No Source Found"], next: { "Source Found": "Mitigate Interference", "No Source Found": "Check WiFi Channel" } },
                { question: "Change WiFi Channel", options: ["Improved", "No Improvement"], next: { "Improved": "Monitor Performance", "No Improvement": "Check Connected Devices" } },
                { question: "Manage Bandwidth", options: ["Improved", "No Improvement"], next: { "Improved": "Monitor Performance", "No Improvement": "Check Router Firmware" } },
                { question: "Update Router Firmware", options: ["Update Successful", "Update Failed/No Update"], next: { "Update Successful": "Monitor Performance", "Update Failed/No Update": "Consider Router Reset" } }
            ];
            let currentStep = steps[0]; // Start at the beginning

            function updateFlowchart() {
                if (!flowchart || !currentStep) return; // Guard clause
                flowchart.innerHTML = `
                    <div class="decision-node">
                        <h4>${currentStep.question}</h4>
                        ${currentStep.options.map(opt =>
                            `<button onclick="selectFlowchartOption('${opt}')">${opt}</button>`
                        ).join('')}
                    </div>
                `;
            }

            // Make function globally accessible for onclick handlers
            window.selectFlowchartOption = function(option) {
                const nextStepQuestion = currentStep.next[option];
                // Find step by question text (ensure questions are unique identifiers in this context)
                const nextStep = steps.find(s => s.question === nextStepQuestion);
                if (nextStep) {
                    currentStep = nextStep;
                    updateFlowchart();
                } else {
                    console.error("Next step not found for option:", option, "from step:", currentStep.question);
                    // Optional: Reset or show error message
                    // currentStep = steps[0]; // Reset to start
                    // updateFlowchart();
                }
            };

            // --- Initializations ---
            function updateRouterPosition(x, y) {
                if (!router || !routerPlacement) return;

                // Ensure coordinates are numbers and within bounds
                x = Math.round(Math.max(0, Math.min(x, routerPlacement.offsetWidth - routerDimensions.width)));
                y = Math.round(Math.max(0, Math.min(y, routerPlacement.offsetHeight - routerDimensions.height)));

                // Update position state
                lastKnownPosition = { x, y };

                // Update position only with left/top (no transform)
                router.style.left = x + 'px';
                router.style.top = y + 'px';

                // Schedule signal update with the new position
                requestAnimationFrame(() => {
                    updateSignalStrength();
                    updateSignalInfo();
                });
            }

            function initializeSimulator() {
                if (!routerPlacement || !signalStrengthCanvas || !router) {
                    console.error('Required elements not found for simulator initialization');
                    return;
                }

                // Get initial router dimensions
                const rect = router.getBoundingClientRect();
                routerDimensions.width = rect.width || 60; // Updated default size
                routerDimensions.height = rect.height || 60; // Updated default size

                // Initialize canvas with correct dimensions and clear any previous state
                updateCanvasDimensions();
                if (signalCtx) {
                    signalCtx.clearRect(0, 0, signalStrengthCanvas.width, signalStrengthCanvas.height);
                }
                
                // Initialize floorplan
                initializeFloorplan();

                // Set initial router position in Living Room
                const initialLivingRoom = floorplanData.rooms.find(r => r.name === "Living Room");
                if (initialLivingRoom) {
                    // Calculate center position of Living Room
                    const centerX = Math.round(initialLivingRoom.x + (initialLivingRoom.width / 2) - (routerDimensions.width / 2));
                    const centerY = Math.round(initialLivingRoom.y + (initialLivingRoom.height / 2) - (routerDimensions.height / 2));
                    
                    // Disable transitions temporarily
                    router.style.transition = 'none';
                    router.style.transform = 'none';
                    
                    // Set initial position directly
                    updateRouterPosition(centerX, centerY);
                    
                    // Force a reflow
                    router.offsetHeight;
                    
                    // Enable transitions and update visualization
                    requestAnimationFrame(() => {
                        router.style.transition = 'left 0.05s ease-out, top 0.05s ease-out';
                    });
                } else {
                    updateRouterPosition(50, 50);
                }

                // Set initial styles
                router.style.cursor = 'grab';
                
                // Initialize flowchart
                updateFlowchart();
            }

            // Wait for a brief moment to ensure DOM is fully ready
            setTimeout(initializeSimulator, 100);
        });
    </script>
</body>
</html>
